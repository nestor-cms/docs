












<h2>
    <a name="_Toc517175173"></a>
    <a name="_Develop"></a>
    Develop
</h2>
<h2>
    <a name="_Toc517175174">The Core Engine</a>
</h2>
<p>
    The heavy lifting in the Nestor system is performed by a set of core engine
    classes that work together to build the final page. There are many ways to
    interact with the core engine, either by using standard Components
    installed with the system, or by building your own custom Components. The
    classes that comprise the core engine allow for flexibility for both system
    configuration and extensibility; however due to the complexity of their
    constituent code
    <strong>
        we don’t recommend making changes directly to these classes
    </strong>
    .
</p>
<p>
    Each of the Core Engine classes has a number of public methods and
    properties you can call when building your own class, as well as code used
    for the inherent system processes that we strongly caution you against
    altering.
</p>
<p>
    The following section describes each of these core engine classes, and
    links out to the full public API for each class.
</p>
<h3>
    <a name="_Toc517175175">DB Class</a>
</h3>
<p>
    The DB Class manages all interactions with the system database. There are
    methods in this class that help you easily fetch, add, update and delete
    data. DB is instantiated in the initiate process of Page Build and added to
    the global $vce object, so the $db object is available to any Components.
    Be sure to call “global $vce” in any function in which you call to db
    methods to ensure it’s available to your function.
</p>
<p>
    The
    <a
        href="https://uwnetid.sharepoint.com/sites/og_cultivate-learning-nestor/Shared%20Documents/Documentation/DB%20Class.docx"
    >
        DB Class API
    </a>
    details methods and properties available for use .
</p>
<h3>
    <a name="_Toc517175176">Content Class</a>
</h3>
<p>
    The global $content object stores HTML produced by other Components in its
    various properties, the most common being $premain, $main and $postmain. At
    the end of the page build process, the global $content object outputs all
    stored content to the browser.
</p>
<p>
    The $content object also creates the HTML for the menu list, which is used
    to populate site theme pages.
</p>
<p>
    Content is instantiated in the initiate process of Page Build and added to
    the global $vce object, so the $content object is available to any
    Components. Be sure to call “global $vce” in any function in which you call
    to $content methods to ensure it’s available to your function.
</p>
<p>
    The
    <a
        href="https://uwnetid.sharepoint.com/sites/og_cultivate-learning-nestor/Shared%20Documents/Documentation/Content%20Class.docx?web=1"
    >
        Content Class API
    </a>
    details methods and properties available for use.
</p>
<h3>
    <a name="_Toc517175177">Site Class</a>
</h3>
<p>
    The Site class stores metadata used by the site such as theme, site
    description,
    <a
        href="https://uwnetid.sharepoint.com/sites/og_cultivate-learning-nestor/Shared%20Documents/Documentation/Nestor%20Documentation.docx#_Hooks"
    >
        Hooks
    </a>
    and the relative URL for the codebase. It contains methods to manage
    datalists, which allow you to store data for use by your custom Component.
    Site manages file dependencies for your Component, as well as any scheduled
    <a
        href="https://uwnetid.sharepoint.com/sites/og_cultivate-learning-nestor/Shared%20Documents/Documentation/Nestor%20Documentation.docx#_Cron_Tasks"
    >
        (cron) tasks
    </a>
    you’d like to add to the system. This class also manages a set of Session
    attributes that can be used to store temporary or persistent values across
    a session. Lastly, Site has a method that allows you to add User Roles to
    your installation, as well as Role specific permissions unique to your
    custom Component.
</p>
<p>
    Site is instantiated in the initiate process of Page Build and added to the
    global $vce object, so the $site object is available to any Components. Be
    sure to call “global $vce” in any function in which you call to $site
    methods to ensure it’s available to your function.
</p>
<p>
    The
    <a href="http:">
        Site Class API details methods and properties available for use.
    </a>
</p>
<h3>
    <a name="_Toc517175178">User Class</a>
</h3>
<p>
    The User class contains methods to manage Users in the system, and stores
    information about the current logged in User.
</p>
<p>
    User is instantiated in the initiate process of Page Build and added to the
    global $vce object, so the $use object is available to any Components. Be
    sure to call “global $vce” in any function in which you call to $user
    methods to ensure it’s available to your function.
</p>
<p>
    The User Class API details methods and properties available for use.
</p>
<h3>
    <a name="_Toc517175179">Page Class</a>
</h3>
<p>
    The Page Class parses the requested URL to determine what Recipe to use,
    which Components will be added to the page, and which HTML content will be
    added to the final rendered page based on the user role. The Page and
    Component class interaction is the most complex part of the Page Build
    process, and is thoroughly explained in the Page Build processes section.
</p>
<p>
    Page is instantiated in the initiate process of Page Build and added to the
    global $vce object, so the $page object is available to any Components. Be
    sure to call “global $vce” in any function in which you call to $page
    methods to ensure it’s available to your function.
</p>
<p>
    The Page Class API details methods and properties available for use.
</p>
<h3>
    <a name="_Toc517175180">Component Class</a>
</h3>
<p>
    The Component Class is the base class from which all components are
    extended. This class contains a core set of methods and properties that
    provide key functionality for all Components, as well as a set that can be
    overwritten. The rest of the Nestor system provides a robust scaffolding
    onto which you can build new features in your component that can plug into
    the system at almost all levels.
</p>
<p>
    See the Extending the Component Class section for full details about
    extending the Component class and interacting with the Nestor core engine.
</p>
<p>
    Component Class API
</p>
<h2>
    <a name="_Toc517175181">DataBase</a>
</h2>
<p>
    The database driving the Nestor system was built to be entirely adaptable
    to any scenario you are addressing. Instead of a standard relational
    architecture, Nestor is hierarchical within the main object tables, and
    then associated data is stored in separate tables as key-value pairs.
    Additional component-specific data can also be stored in the database in
    the form of
    <a
        href="https://uwnetid.sharepoint.com/sites/og_cultivate-learning-nestor/Shared%20Documents/Documentation/Nestor%20Documentation.docx#_Datalists"
    >
        datalists
    </a>
    . This system allows for a great deal of back-end flexibility when you are
    designing your component architecture.
</p>
<h3>
    <a name="_Toc517175182">Table Structure</a>
</h3>
<p>
    During the installation process, you provided a path value that is appended
    to the beginning of each table name. In the following documentation, this
    path is represented by [<em>my_db</em>] notation. This section will
    describe each tables function and general contents, but to see the full
    table schema refer to your instance of the database in MySQL. You can use
    the MySQL Admin tool that installed with your version of MAMP/WAMP.
</p>
<h4>
    [<em>my_db</em>]_components Table
</h4>
<p>
    The components table stores general information about each component,
    including its ID and parent ID. The parent ID provides the hierarchical
    relationship that defines structures within the database. A component will
    have a value for url if it represents the top (“anchor”) component in a
    recipe.
</p>
<h4>
    [<em>my_db</em>]_components_meta Table
</h4>
<p>
    This table holds all associated metadata for a component, and is set up
    using ‘meta_key’ and ‘meta_value’ fields that can be populated with any
    key/value pairs relevant to your scenario. There are key/value pairs
    standard for every component, including type, created_by, created_at, and
    title. Other pairs are only relevant to some components, such as recipe and
    role access. And other values can be inserted by your custom component if
    needed.
</p>
<h4>
    [<em>my_db</em>]_site_meta Table
</h4>
<p>
    The site_meta table contains all of the information relevant to your
    installation of Nestor. All of these site properties are thoroughly
    detailed in the Site Class API document.
</p>
<h4>
    [<em>my_db</em>]_users Table
</h4>
<p>
    The users table holds the user ID and role ID, as well as the vector for
    decryption and the hashed value of the user login and password information.
</p>
<h4>
    [<em>my_db</em>]_users_meta Table
</h4>
<p>
    The users_meta table holds metadata associated with each user, stored as
    key/value pairs. All personal data is encrypted, the vector needed for
    decryption is stored in the users table for each user.
</p>
<h3>
    <a name="_Toc517175183"></a>
    <a name="_Datalists"></a>
    Datalists
</h3>
<p>
    Datalists allow you to store Component specific data in a very flexible
    format. Data can be associated with components, users, or other entities
    you design. A datalist can be associated with items, each item can in turn
    act as a datalist with its own associated items.
</p>
<p>
    Datalists and Datalist items can be added, updated and deleted through a
    series of methods in the Site Class. Refer to the Site Class API for more
    details about managing datalists programmatically. You can also manage
    Datalists using the
    <a
        href="https://uwnetid.sharepoint.com/sites/og_cultivate-learning-nestor/Shared%20Documents/Documentation/Nestor%20Documentation.docx#_Manage_Datalists"
    >
        Manage Datalists page
    </a>
    .
</p>
<p>
    Datalists are contained in four tables:
</p>
<h4>
    [<em>my_db</em>]_datalists Table
</h4>
<p>
    The datalists table contains all of the IDs that define a datalist. All
    values are optional except for the datalist ID, which is an auto-generated
    primary key.
</p>
<p>
    · datalist ID – distinct ID that identifies the datalist
</p>
<p>
    · parent ID - this datalist is associated with another datalist
</p>
<p>
    · user ID - the data is associated with a specific user
</p>
<p>
    · component ID – the data is associated with a specific component
</p>
<p>
    · item ID – There is an associated item ID, which is also acting as a
    datalist. Creating a new datalist in this scenario creates a hierarchy that
    allows an item to have its own items. See the
    <a
        href="https://uwnetid.sharepoint.com/sites/og_cultivate-learning-nestor/Shared%20Documents/Documentation/Nestor%20Documentation.docx#_State/City_Datalist_example:"
    >
        State/City datalist example
    </a>
    for an illustration of this concept.
</p>
<p>
    · sequence – the order in which this datalist would appear in a list
</p>
<h4>
    [<em>my_db</em>]_datalists_meta Table
</h4>
<p>
    The datalists_meta table holds all of the data associated with the
    datalist, in key/value pairs. This structure is identical to the
    components_meta and site_meta tables and allows you the same flexibility to
    design your data structure.
</p>
<h4>
    [<em>my_db</em>]_datalists_items Table
</h4>
<p>
    If you will be associating multiple items with your datalist, the
    datalists_items table stores these items. This table contains the IDs that
    define an item.
</p>
<p>
    · item ID: distinct ID that identifies the item
</p>
<p>
    · datalist ID: the datalist with which this item is associated
</p>
<p>
    · sequence: the order in which this item would appear in a list
</p>
<h4>
    [<em>my_db</em>]_datalists_items_meta Table
</h4>
<p>
    The datalists_items_meta table holds all of the data associated with the
    item, in key/value pairs. This structure is identical to the datalists_meta
    table and allows you the same flexibility to design your data structure.
</p>
<h4>
    <a name="_State/City_Datalist_example:"></a>
    State/City Datalist example
</h4>
<p>
    In this scenario, the top level datalist represents a state entity, which
    can have multiple items representing distinct states. Each state can have
    multiple cities. In order to associate the city items to the state item, a
    new datalist is created that represents a distinct state.
</p>
<p>
    <img
        border="0"
        width="935"
        height="568"
        src="file:///C:/Users/cdoring/AppData/Local/Temp/msohtmlclip1/01/clip_image058.jpg"
    />
</p>
<p>
    <em>State/City scenario</em>
</p>
<p>
    In the data structure each item contains the datalist ID of its parent
    datalist. When an item in turn becomes a datalist, the new datalist
    contains the item ID of its parent item. The new datalist will also have a
    parent ID of the first level datalist.
</p>
<p>
    <img
        border="0"
        width="1064"
        height="802"
        src="file:///C:/Users/cdoring/AppData/Local/Temp/msohtmlclip1/01/clip_image060.jpg"
    />
</p>
<p>
    <em>State/City database table representation</em>
</p>
<h2>
    <a name="_Toc517175184"></a>
    <a name="_Toc517175187">The Page Build Processes</a>
</h2>
<p>
    There are a couple of key processes in which the core engine classes
    interact with the page components to build out each page. These processes
    have been extensively documented in this section.
</p>
<h3>
    <a name="_Toc517175188">Overview</a>
</h3>
<p>
    The Page Build process follows the same path each time, but the actual
    rendered page is determined by the Components and Recipe associated with
    the requested page. The
    <a
        href="https://teams.microsoft.com/_#/vsdx/viewer/teams/https%3A~2F~2Fuwnetid.sharepoint.com~2Fsites~2Fog_cultivate-learning-nestor~2FShared%2520Documents~2FDocumentation~2FNestor%2520Codeflow.vsdx?threadId=19%3A1fb54ab236ea45bc9efca5b43c470eea%40thread.skype&amp;fileId=DD2DF85B-2E15-4573-837F-7"
    >
        Nestor Codeflow Chart
    </a>
    shows how each of the core engine classes, as well as a few configuration
    files, interact to render the final page.
</p>
<p>
    To follow the page build flow:
</p>
<p>
    1) The lane on the far left, labeled “Initiate”, contains the major steps
    in the Page Build process. This lane roughly follows the code flow in
    initiate.php
</p>
<p>
    2) During execution of initiate.php, all of the major Core Engine classes
    are loaded and instantiated, and then added to the master $vce object. The
    master $vce class allows for ease of access to each of these objects from
    other components.
</p>
<p>
    3) All of the colored circles in the Initiate lane represent control
    passing to one of the Core Engine classes. When you see a colored circle,
    look for a corresponding colored circle across the top of the lanes. Each
    of these lanes represents the events in the __construct() method of the
    class.
</p>
<p>
    4) Follow the flow down the lane for each class to learn about its
    function. At the end of the lane flow, you’ll reach a second colored circle
    indicating that control is passed back to the Initiate process flow
</p>
<p>
    5) In a few cases, control is passed back and forth between the Core Engine
    classes. This will be indicated by flow arrows crossing the lane boundaries
</p>
<p>
    6) The squares colored light green represent Hooks. These are areas in the
    process where you can insert a call to a method in your custom Component.
    See the
    <a
        href="https://uwnetid.sharepoint.com/sites/og_cultivate-learning-nestor/Shared%20Documents/Documentation/Nestor%20Documentation.docx#_Hooks"
    >
        Hooks Section
    </a>
    for more information.
</p>
<h3>
    <a name="_Toc517175189">Page Request Routing</a>
</h3>
<p>
    There are a few things that are important to understand about how the page
    requests are routed by Nestor:
</p>
<p>
    · All calls into your Nestor installation are intercepted by the .htaccess
    file and routed to index.php if the requested path doesn’t specify an
    existing file or directory
</p>
<p>
    · Index.php sets a few values and then loads initiate.php, which drives the
    build process
</p>
<p>
    · If the requested path contains a URL value recognized by the system, the
    page will be built according to the Recipe with the designated URL (see
    <a
        href="https://uwnetid.sharepoint.com/sites/og_cultivate-learning-nestor/Shared%20Documents/Documentation/Nestor%20Documentation.docx#_Manage_Recipes_2"
    >
        Manage Recipes
    </a>
    section for more information)
</p>
<p>
o The URL value is found in this pattern: <em>[my_servername]</em>/    <em>[my_nestor]</em>/<strong>URL</strong>
</p>
<p>
§ For example, in the path    <a href="http://localhost/vce/admin">http://localhost/vce/admin</a> -
    ‘admin’ is the URL value
</p>
<p>
    o You can also add a ‘~[component_id]’ to the path querystring to render a
    specific component. This must be a page level component, or you will not
    see a properly rendered page.
</p>
<p>
§ For example:    <a href="http://localhost/vce/~1">http://localhost/vce/~1</a> will load the
    recipe associated with the component with component_id of 1
</p>
<p>
    · If the requested URL is not recognized, or the request is not accompanied
    by the correct security handshake, the request is routed to the home page
</p>
<h3>
    <a name="_Toc517175190">Interaction between Page and Component classes</a>
</h3>
<p>
    When the Page object is instantiated during Initiation, it kicks off the
    most complex phases of the Page Build process. The intricate interaction
    between Page, other core engine classes, and page Components provides a
    rich opportunity to build custom code to affect the final rendered page. By
    design, the Page class calls into specific methods in each component it
    processes during Page Build. Also, there are many Hooks invoked during Page
    Build into which your custom Component can insert code.
</p>
<p>
    The
    <a
        href="https://teams.microsoft.com/_#/vsdx/viewer/teams/https%3A~2F~2Fuwnetid.sharepoint.com~2Fsites~2Fog_cultivate-learning-nestor~2FShared%2520Documents~2FDocumentation~2FNestor%2520Codeflow.vsdx?threadId=19%3A1fb54ab236ea45bc9efca5b43c470eea%40thread.skype&amp;fileId=DD2DF85B-2E15-4573-837F-7"
    >
        Nestor Codeflow Chart
    </a>
    shows how each of the core engine classes, configuration files, hooks and
    page components interact to render the final page.
</p>
<h3>
    <a name="_Toc517175191">Build Components Array Process</a>
</h3>
<p>
    Since the components hold all of the information about how a page is built,
    it’s important to assemble an array that contains all of the components
    associated with the page under construction. This array includes the
    metadata that defines each component. A key piece of metadata is the page
    Recipe which is discovered and added to the global $page object during this
    process. Also, there is a parent-child-sibling hierarchy between Components
    that must be reflected in the array. In order to build out this
    multifarious component tree, there are many levels of recursion executed in
    the two Page methods involved in building out the array – get_components()
    and get_sub_components().
</p>
<p>
    This process is documented in the
    <a
        href="https://uwnetid.sharepoint.com/:u:/r/sites/og_cultivate-learning-nestor/_layouts/15/doc.aspx?sourcedoc=%7Bdd2df85b-2e15-4573-837f-7523755d63e4%7D&amp;action=default&amp;uid=%7BDD2DF85B-2E15-4573-837F-7523755D63E4%7D&amp;ListItemId=5&amp;ListId=%7B53A752AB-53D8-45B4-88F4-D748E5622CCE%7D&amp;odsp=1&amp;env=prod"
    >
        Build Components Array Process
    </a>
    flowchart, which not only shows the control flow between methods and
    classes, but also indicates where hooks are invoked in which you can insert
    your own custom methods.
</p>
<h3>
    <a name="_Toc517175192">Build Content Process</a>
</h3>
<p>
    Once the full Component array has been populated, it’s time to build out
    the HTML content that is rendered on the final page. This process involves
    traversing the component array structure and comparing it to the page
    Recipe, component-by-component. Comparing the two allows the process to
    check for Role-based access as well as call specific methods in each
    component to determine what content should be written out to the page.
    There are opportunities for your custom component to stop the entire Page
    Build within this process if there are scenarios where it makes sense for
    your component to do so.
</p>
<p>
    This process is documented in the
    <a
        href="https://uwnetid.sharepoint.com/:u:/r/sites/og_cultivate-learning-nestor/_layouts/15/doc.aspx?sourcedoc=%7Bdd2df85b-2e15-4573-837f-7523755d63e4%7D&amp;action=default&amp;uid=%7BDD2DF85B-2E15-4573-837F-7523755D63E4%7D&amp;ListItemId=5&amp;ListId=%7B53A752AB-53D8-45B4-88F4-D748E5622CCE%7D&amp;odsp=1&amp;env=prod"
    >
        Build Content Process
    </a>
    flowchart, which not only shows the control flow between methods and
    classes, but also indicates where hooks are invoked in which you can insert
    your own custom methods.
</p>
<h2>
    Build a Custom Component
</h2>
<p>
    Nestor is easily extensible for developers, as it was designed to allow
    custom components to access the core system at multiple levels. This
    section details how to build your own custom component.
</p>
<h3>
    <a name="_Toc517175185">Component Quick Start</a>
</h3>
<p>
    We have included a sample component in the standard Nestor Installation to
    help jumpstart your customization. The sample component – Blog-o-rama – is
    located in the [<em>my_nestor]\</em>vce-content\components\blog-o-rama
    directory.
</p>
<p>
    Follow these quick steps to start building your first component:
</p>
<p>
    1) Open the blog-o-rama.php file into your code editor of choice
</p>
<p>
    2) You can change the Class name, but if you do so, it’s best to update the
    file name and the folder name in which the component resides for
    continuity. The folder, file and Class name should be the same.
</p>
<p>
    3) In the component_info( ) method, change the title, description and
    category values
</p>
<p>
    4) In the as_content method, change the value of $my_content to the value
    you’d like to display. You can include HTML tags, but make sure that if you
    use special characters in your text that you use the proper escape syntax
</p>
<p>
    5) Open the Manage Components page, and click on the category matching the
    category you set in step 2. Note that your name and description component
    values from this step also display in this interface.
</p>
<p>
6) You should see your component in the list. Click the<strong>Activated</strong> button next to your component name and then the    <strong>Update Components</strong> button to activate your component.
</p>
<p>
    7) Open the Manage Recipes page and add your component to a recipe. Make
    sure you include a Location component with a URL value.
</p>
<p>
    8) Open the Manage Menus page and add your new page to the main menu
</p>
<p>
    9) Click on the new menu item with your component name and you will see
    your component on a page!
</p>
<p>
    10) Read further to understand how to extend your class beyond these basic
    Component methods
</p>
<h3>
    <a name="_Toc517175186"></a>
    <a name="_Page_Build_Process"></a>
    <a name="_Building_a_Custom"></a>
    Extending the Component Class
</h3>
<p>
    Building a custom component involves extending the Component class, which
    contains properties and methods that are linked directly into core system
    processes. Extending this class allows you to layer new features and
    functionality onto Nestor, and still provides the same abilities to allow
    end users to add content of their own when using the system. Also, there
    are many hooks with which the components can interact with the main engine
    at various stages of the page build process.
</p>
<p>
    Refer to the Component Class API document to get detailed information about
    the available methods that you can use to interact with the Nestor System,
    and standard properties associated with components. The following section
    describes system processes performed by the core engine classes that you
    will be able to influence with your component.
</p>
<h2>
    <a name="_Toc517175194">Hooks</a>
</h2>
<p>
    Hooks are a powerful tool that allow your component to 'hook into' the
    Nestor engine at various stages of the page build process, as well as any
    place in the code where a hook has been inserted. A hook is configured
    within a component class and designates a class and method to call when the
    hook is invoked within the system. In the Nestor system, a class/method
    pairing is known as a procedure.
</p>
<p>
    During the page build process, the procedure/hook associations are loaded
    into a hooks array that’s added to the global $site object. The Hooks
    Definition and Load Process flow chart shows the end-to-end process of
    defining a hook and loading into the system for use.
</p>
<p>
    Read the Adding a Hook section in the Component API document to learn how
    to associate a procedure with a hook in the Nestor system.
</p>
<h3>
    <a name="_Toc517175195">Hooks in the Page Build Process</a>
</h3>
<p>
    The following flow charts depict when the major system hooks are invoked
    during the Page Build process. You can use these charts to design your own
    component hooks if you need to influence the build process at any point.
    Hooks are shown as green boxes. Note that some hooks receive parameters to
    route to the designated procedures, and some change the value of passed
    parameters and send the changed value back into the method from which the
    hook is invoked. Each hook representation in the flow chart details how
    parameters are processed by the hook procedure.
</p>
<p>
    1) Page Build Process – shows the high level process, hooks displayed are
    invoked during the instantiation of the $site, $user and $page objects
</p>
<p>
    2) Build Component Array Process – shows the detailed process of building
    the component array, with hooks invoked by get_components and
    get_subcomponents methods of the Page class
</p>
<p>
    3) Build Content Process – depicts the hooks invoked during the complex
    interaction between classes (primarily Page and Component) to render the
    page content.
</p>
<h3>
    <a name="_Toc517175196">Hooks in the Core Engine Classes</a>
</h3>
<p>
    The following section lists the hooks found in core engine classes, as well
    as some other standard component classes. Each hook follows a standard
    nomenclature to make it easier to trace their origin and function:
</p>
<p>
    [Class-name]_[method-name]_[brief-description]
</p>
<p>
    This list is not exhaustive for the system.
</p>
<h4>
    at_user_login
</h4>
<p>
    · Can be used to perform function using current user ID
</p>
<p>
    · called in User::login and User::__construct after user object is created
</p>
<p>
    · arguments passed: user_id
</p>
<p>
    · no return value
</p>
<h4>
</h4>
<h4>
    at_user_logout
</h4>
<p>
    · Can be used to perform function using current user ID
</p>
<p>
    · called in User::logout at the very end, after session info is cleared
</p>
<p>
    · arguments passed: user_id
</p>
<p>
    · no return value
</p>
<h4>
    alternative_user_login
</h4>
<p>
    · Can be used to create an alternative method to login if there is no user
    session or persistent login set
</p>
<p>
    · called in User::__construct after performing auto login for user with a
    session or persistent login
</p>
<p>
    · arguments passed: $user
</p>
<p>
    · no return value
</p>
<h4>
    build_content_recipe_item
</h4>
<p>
    · Not in code
</p>
<h4>
    ***component_recipe-components_can-add (currently
    page_requested_components)
</h4>
<p>
    · can be used to reverse auto create or alter any of the $input when a
    component is created
</p>
<p>
    · called from Component::create_component
</p>
<p>
    · arguments passed: $input used to create component
</p>
<p>
    · return $input array
</p>
<h4>
    create_component_before
</h4>
<p>
    · can be used to reverse auto create or alter any of the $input when a
    component is created
</p>
<p>
    · called from Component::create_component
</p>
<p>
    · arguments passed: $input used to create component
</p>
<p>
    · return $input array
</p>
<p>
    <strong></strong>
</p>
<h4>
    delete_extirpate_component
</h4>
<p>
    · can be used to alter $components array before deletion of members.
    $components array consists of sub-components of either the component being
    extirpated, or sub-components of one of its descendants
</p>
<p>
    · called from Component::extirpate_component
</p>
<p>
    · arguments passed: $component_id (parent ID of $components), $components
    (sub-components of current parent)
</p>
<ul>
    <li>
        return $components
    </li>
</ul>
<h4>
    input_sanitize_textarea
</h4>
<ul>
    <li>
        Can be used to sanitized form input from a text area
    </li>
</ul>
<p>
    · Called from Input::page_requested_url if originating form field was a
    textarea
</p>
<ul>
    <li>
        arguments passed: $value of text
    </li>
    <li>
        return $value
    </li>
    <li>
    </li>
</ul>
<h4>
    media_after_display
</h4>
<p>
    · Can be used to perform a function on a mediatype component after its
    display and edit_media_component methods are called
</p>
<ul>
    <li>
        Called from Media::as_content
    </li>
</ul>
<p>
    · arguments passed: $each_component (media player being displayed), $vce
</p>
<p>
    · no return
</p>
<h4>
    media_before_display
</h4>
<p>
    · Can be used to perform a function on a mediatype component before its
    display method is called
</p>
<ul>
    <li>
        Called from Media::as_content
    </li>
</ul>
<p>
    · arguments passed: $each_component (media player being displayed), $vce
</p>
<p>
    · no return
</p>
<h4>
    media_create_component
</h4>
<p>
    · Can be used to alter the input for a new media component before it’s
    created
</p>
<ul>
    <li>
        Called from Media::create and Mediaplupload:create
    </li>
    <li>
        arguments passed: $input used to create media component
    </li>
</ul>
<p>
    · return $input array
</p>
<h4>
    media_component_created
</h4>
<ul>
    <li>
        Called after a new media component is created
    </li>
    <li>
        Called from Media::create
    </li>
</ul>
<p>
    · arguments passed: $input used to create media component, $response array
</p>
<p>
    · return $response
</p>
<h4>
    media_file_uploader
</h4>
<ul>
    <li>
        Can be used to add content before the file upload button
    </li>
    <li>
        Called from Media::add_file_uploader
    </li>
    <li>
        arguments passed: $recipe_component, $vce
    </li>
    <li>
        return $content_media that is added to the page
    </li>
</ul>
<h4>
    media_update_component
</h4>
<ul>
    <li>
        Called from Media::update before update_component method is called
    </li>
    <li>
        arguments passed: $input used for update
    </li>
    <li>
        return $input
    </li>
</ul>
<h4>
    media_delete_component
</h4>
<ul>
    <li>
        Called from Media::delete before delete_component method is called
    </li>
    <li>
        arguments passed: $input used for delete
    </li>
    <li>
        return $input
    </li>
</ul>
<h4>
    page_add_recipe
</h4>
<p>
    · called when recipe is added to $page in get_components and
    get_sub_components
</p>
<ul>
    <li>
        Page::get_components
    </li>
</ul>
<p>
    · arguments passed: $page-&gt;recipe and recipe found in current component
</p>
<p>
    · return recipe, which is assigned to $page
</p>
<h4>
    page_build_content
</h4>
<p>
    · called for each component at the beginning of Build Content process
</p>
<p>
    · called in Page::build_content
</p>
<p>
    · arguments passed: $each_component from $components array, $linked
</p>
<p>
    · no return value
</p>
<h4>
    page_build_content_callback
</h4>
<p>
    · Called before recursive call to build_content for current component
</p>
<p>
    · Called in Page::build_content
</p>
<p>
    · Arguments passed: $sub_components from current component
</p>
<p>
    · returns $sub_components
</p>
<h4>
    page_construct_object
</h4>
<p>
    · called in Page::__construct after requested_component object is pulled
    from db
</p>
<p>
    · arguments passed: $requested_component, $vce
</p>
<p>
    · no return value
</p>
<h4>
    page_get_components
</h4>
<p>
    · Called in Page::get_components before recursive call back to
    get_components
</p>
<p>
    · arguments passed: $requested_component, $components, $page
</p>
<ul>
    <li>
        no return
    </li>
</ul>
<h4>
    page_get_sub_components
</h4>
<p>
    · Called in Page::get_sub_components before building full sub_components
    tree
</p>
<p>
    · arguments passed: $requested_components
</p>
<ul>
    <li>
        return $requested_components
    </li>
</ul>
<h4>
    page_requested_components
</h4>
<p>
    · Can be used to alter $requested_component at the beginning of
    get_components method
</p>
<p>
    · Called at start of Page::get_components, after call to db to get
    requested component object
</p>
<p>
    · arguments passed: $requested_component
</p>
<ul>
    <li>
        return $requested_component
    </li>
</ul>
<h4>
    page_requested_url
</h4>
<p>
    · Called in Page::__construct after $requested_url is cleaned up and
    sanitized
</p>
<ul>
    <li>
        arguments passed: $requested_url, $vce
    </li>
    <li>
        no return
    </li>
</ul>
<h4>
    recipe_attributes
</h4>
<p>
    · Adds fields on recipe page after Recipe Name
</p>
<p>
    · called in ManageRecipes::as_content
</p>
<p>
    · arguments passed: $vce-&gt;user
</p>
<p>
    · returns string of HTML content with additional attributes, to be added to
    Manage Recipe page
</p>
<h4>
    recipe_components_each
</h4>
<ul>
    <li>
        Components::recipe_components
    </li>
</ul>
<h4>
    requested_sub_components
</h4>
<p>
    · Called at start of Page::get_sub_components, after call to db to get
    array of sub components
</p>
<p>
    · arguments passed: $requested_components
</p>
<ul>
    <li>
        return $requested_components
    </li>
</ul>
<h4>
    site_hook_initiation
</h4>
<p>
    · The earliest hook that can be used
</p>
<p>
    · called in Site:__construct
</p>
<p>
    · arguments passed: $hooks array
</p>
<p>
    · no return value
</p>
<h4>
    site_javascript_dependencies
</h4>
<p>
    · can be used to alter the site-&gt;javascript_dependencies array
</p>
<p>
    · called in Site::__construct after javascript &amp; CSS files are added to
    site
</p>
<p>
    · arguments passed: $site, $site-&gt;javascript_dependencies
</p>
<p>
    · return javascript_dependencies array
</p>
<h4>
    site_mail_transport
</h4>
<p>
    · can be used to route mail message to a different transport method
</p>
<p>
    · if it exists, is called in VCE::mail instead of PHP mailer call
</p>
<p>
    · arguments passed: $vce, $attributes
</p>
<p>
    · return status of message call
</p>
<h4>
    site_media_link
</h4>
<p>
    · can be used to alter path to which media is uploaded
</p>
<ul>
    <li>
        called in Site::media_link after $media_link path is built
    </li>
</ul>
<p>
    · arguments passed: $fileinfo arrray, $this
</p>
<ul>
    <li>
        returns $media_link
    </li>
</ul>
<h4>
    site_object_construct
</h4>
<p>
    · Can be used to modify the site object
</p>
<p>
    · called in Site::__construct
</p>
<p>
    · arguments passed: $site object
</p>
<p>
    · no return value
</p>
<h4>
    user_attributes
</h4>
<p>
    · Used to add additional user attributes
</p>
<p>
    · called in: ManageUsers::as_content, UserRegistration::as_content,
    UserSettings::as_content
</p>
<p>
    · arguments passed: $user_info array
</p>
<p>
    · returns string of HTML content with additional user attributes, to be
    added to Manage Users page
    <br/>
    <br/>
</p>
<h2>
    <a name="_Toc517175197"></a>
    <a name="_Templates_1"></a>
    Templates
</h2>
<ul>
    <li>
        existing
    </li>
</ul>
<p>
    · creating a new one
</p>
<h3>
    <a name="_Toc517175198">JavaScript Dependencies</a>
</h3>
<p>
    · How to add a new .js file
</p>
<p>
    · Files used in system
</p>
<p>
    o jQuery
</p>
<p>
    o JSON
</p>
<p>
    o vce.js
</p>
<p>
    o other js files used in system (manage components…?)
</p>
<ul>
    <li>
        clickbars?
    </li>
</ul>
<h3>
    <a name="_Toc517175199">CSS dependencies</a>
</h3>
<p>
    · How to add a new .css file
</p>
<p>
    · Files used in system
</p>
<p>
    o jQuery
</p>
<h2>
    <a name="_Toc517175200">Cron Tasks</a>
</h2>
<p>
    Cron tasks allow you to schedule tasks for the system. These cron tasks are
    defined by methods within Components Classes that are called during page
    build. Cron tasks are useful when you need to sync with external systems,
    such as connecting to external service providers. They can also be used for
    general housekeeping – in Nestor they go through user comments looking for
    any blank entries and deleting them every day.
</p>
<h4>
    Data Structure
</h4>
<p>
    A cron task takes the form of a record in the site_meta table, and contains
    the following information:
</p>
<table border="1" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td width="198" valign="top">
                <p>
                    component
                </p>
            </td>
            <td width="738" valign="top">
                <p>
                    Name of the Component Class that contains the method to be
                    called
                </p>
            </td>
        </tr>
        <tr>
            <td width="198" valign="top">
                <p>
                    method
                </p>
            </td>
            <td width="738" valign="top">
                <p>
                    Name of the method to call. Since cron_tasks are called
                    before the components are instantiated, the method needs to
                    be static
                </p>
            </td>
        </tr>
        <tr>
            <td width="198" valign="top">
                <p>
                    properties
                </p>
            </td>
            <td width="738" valign="top">
                <p>
                    A list of key/value pairs to provide more information about
                    the task, for example the component_id
                </p>
            </td>
        </tr>
        <tr>
            <td width="198" valign="top">
                <p>
                    timestamp
                </p>
            </td>
            <td width="738" valign="top">
                <p>
                    A timestamp value to indicate when the task has expired
                </p>
            </td>
        </tr>
    </tbody>
</table>
<h4>
    Cron Task Management
</h4>
<p>
    During the page build process, the Site class loads all of the cron tasks
    from the site_meta table into a cron_tasks array, and then parses through
    the array to look for any expired timestamps. If a task has an expired
    timestamp, the Site class will call the method indicated by the cron task.
    If this method sends a response in the form of an array, the Site class
    updates the cron task with the new values. If the method does not send a
    response the Site class will delete this task from the system. See the
    <a
        href="https://uwnetid.sharepoint.com/sites/og_cultivate-learning-nestor/Shared%20Documents/Documentation/Site%20Class.docx?web=1"
    >
        Site Class API
    </a>
    for information about how to form a response to manage a cron task.
</p>
<p>
    Since the tasks are performed during the Page build process, the tasks are
    only fired when you have visitors to your site.
</p>
<h4>
    Throttling Cron Tasks
</h4>
<p>
    The CRON_TASK_LIMIT value in the system config file sets the amount of cron
    tasks that will be processed on page load. This allows you to balance the
    load on your system. The amount of cron tasks run on each page load
    defaults to 1 if CRON_TASK_LIMIT isn’t set.
</p>
<h3>
    <a name="_Toc517175201">Session Variables</a>
</h3>
<p>
    · add_attributes Session variables used by the system, especially for
    persistent values?
</p>
<p>
    <a name="_Building_a_Component"></a>
    <a name="_JavaScript_Dependencies"></a>
    <a name="_CSS_dependencies"></a>
    <a name="_Templates"></a>
    <a name="_Hooks"></a>
    <a name="_Cron_Tasks"></a>
</p>