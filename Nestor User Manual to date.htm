


<h2>
    Build a Custom Component
</h2>
<p>
    Nestor is easily extensible for developers, as it was designed to allow
    custom components to access the core system at multiple levels. This
    section details how to build your own custom component.
</p>
<h3>
    <a name="_Toc517175185">Component Quick Start</a>
</h3>
<p>
    We have included a sample component in the standard Nestor Installation to
    help jumpstart your customization. The sample component – Blog-o-rama – is
    located in the [<em>my_nestor]\</em>vce-content\components\blog-o-rama
    directory.
</p>
<p>
    Follow these quick steps to start building your first component:
</p>
<p>
    1) Open the blog-o-rama.php file into your code editor of choice
</p>
<p>
    2) You can change the Class name, but if you do so, it’s best to update the
    file name and the folder name in which the component resides for
    continuity. The folder, file and Class name should be the same.
</p>
<p>
    3) In the component_info( ) method, change the title, description and
    category values
</p>
<p>
    4) In the as_content method, change the value of $my_content to the value
    you’d like to display. You can include HTML tags, but make sure that if you
    use special characters in your text that you use the proper escape syntax
</p>
<p>
    5) Open the Manage Components page, and click on the category matching the
    category you set in step 2. Note that your name and description component
    values from this step also display in this interface.
</p>
<p>
6) You should see your component in the list. Click the<strong>Activated</strong> button next to your component name and then the    <strong>Update Components</strong> button to activate your component.
</p>
<p>
    7) Open the Manage Recipes page and add your component to a recipe. Make
    sure you include a Location component with a URL value.
</p>
<p>
    8) Open the Manage Menus page and add your new page to the main menu
</p>
<p>
    9) Click on the new menu item with your component name and you will see
    your component on a page!
</p>
<p>
    10) Read further to understand how to extend your class beyond these basic
    Component methods
</p>
<h3>
    <a name="_Toc517175186"></a>
    <a name="_Page_Build_Process"></a>
    <a name="_Building_a_Custom"></a>
    Extending the Component Class
</h3>
<p>
    Building a custom component involves extending the Component class, which
    contains properties and methods that are linked directly into core system
    processes. Extending this class allows you to layer new features and
    functionality onto Nestor, and still provides the same abilities to allow
    end users to add content of their own when using the system. Also, there
    are many hooks with which the components can interact with the main engine
    at various stages of the page build process.
</p>
<p>
    Refer to the Component Class API document to get detailed information about
    the available methods that you can use to interact with the Nestor System,
    and standard properties associated with components. The following section
    describes system processes performed by the core engine classes that you
    will be able to influence with your component.
</p>
<h2>
    <a name="_Toc517175194">Hooks</a>
</h2>
<p>
    Hooks are a powerful tool that allow your component to 'hook into' the
    Nestor engine at various stages of the page build process, as well as any
    place in the code where a hook has been inserted. A hook is configured
    within a component class and designates a class and method to call when the
    hook is invoked within the system. In the Nestor system, a class/method
    pairing is known as a procedure.
</p>
<p>
    During the page build process, the procedure/hook associations are loaded
    into a hooks array that’s added to the global $site object. The Hooks
    Definition and Load Process flow chart shows the end-to-end process of
    defining a hook and loading into the system for use.
</p>
<p>
    Read the Adding a Hook section in the Component API document to learn how
    to associate a procedure with a hook in the Nestor system.
</p>
<h3>
    <a name="_Toc517175195">Hooks in the Page Build Process</a>
</h3>
<p>
    The following flow charts depict when the major system hooks are invoked
    during the Page Build process. You can use these charts to design your own
    component hooks if you need to influence the build process at any point.
    Hooks are shown as green boxes. Note that some hooks receive parameters to
    route to the designated procedures, and some change the value of passed
    parameters and send the changed value back into the method from which the
    hook is invoked. Each hook representation in the flow chart details how
    parameters are processed by the hook procedure.
</p>
<p>
    1) Page Build Process – shows the high level process, hooks displayed are
    invoked during the instantiation of the $site, $user and $page objects
</p>
<p>
    2) Build Component Array Process – shows the detailed process of building
    the component array, with hooks invoked by get_components and
    get_subcomponents methods of the Page class
</p>
<p>
    3) Build Content Process – depicts the hooks invoked during the complex
    interaction between classes (primarily Page and Component) to render the
    page content.
</p>
<h3>
    <a name="_Toc517175196">Hooks in the Core Engine Classes</a>
</h3>
<p>
    The following section lists the hooks found in core engine classes, as well
    as some other standard component classes. Each hook follows a standard
    nomenclature to make it easier to trace their origin and function:
</p>
<p>
    [Class-name]_[method-name]_[brief-description]
</p>
<p>
    This list is not exhaustive for the system.
</p>
<h4>
    at_user_login
</h4>
<p>
    · Can be used to perform function using current user ID
</p>
<p>
    · called in User::login and User::__construct after user object is created
</p>
<p>
    · arguments passed: user_id
</p>
<p>
    · no return value
</p>
<h4>
</h4>
<h4>
    at_user_logout
</h4>
<p>
    · Can be used to perform function using current user ID
</p>
<p>
    · called in User::logout at the very end, after session info is cleared
</p>
<p>
    · arguments passed: user_id
</p>
<p>
    · no return value
</p>
<h4>
    alternative_user_login
</h4>
<p>
    · Can be used to create an alternative method to login if there is no user
    session or persistent login set
</p>
<p>
    · called in User::__construct after performing auto login for user with a
    session or persistent login
</p>
<p>
    · arguments passed: $user
</p>
<p>
    · no return value
</p>
<h4>
    build_content_recipe_item
</h4>
<p>
    · Not in code
</p>
<h4>
    ***component_recipe-components_can-add (currently
    page_requested_components)
</h4>
<p>
    · can be used to reverse auto create or alter any of the $input when a
    component is created
</p>
<p>
    · called from Component::create_component
</p>
<p>
    · arguments passed: $input used to create component
</p>
<p>
    · return $input array
</p>
<h4>
    create_component_before
</h4>
<p>
    · can be used to reverse auto create or alter any of the $input when a
    component is created
</p>
<p>
    · called from Component::create_component
</p>
<p>
    · arguments passed: $input used to create component
</p>
<p>
    · return $input array
</p>
<p>
    <strong></strong>
</p>
<h4>
    delete_extirpate_component
</h4>
<p>
    · can be used to alter $components array before deletion of members.
    $components array consists of sub-components of either the component being
    extirpated, or sub-components of one of its descendants
</p>
<p>
    · called from Component::extirpate_component
</p>
<p>
    · arguments passed: $component_id (parent ID of $components), $components
    (sub-components of current parent)
</p>
<ul>
    <li>
        return $components
    </li>
</ul>
<h4>
    input_sanitize_textarea
</h4>
<ul>
    <li>
        Can be used to sanitized form input from a text area
    </li>
</ul>
<p>
    · Called from Input::page_requested_url if originating form field was a
    textarea
</p>
<ul>
    <li>
        arguments passed: $value of text
    </li>
    <li>
        return $value
    </li>
    <li>
    </li>
</ul>
<h4>
    media_after_display
</h4>
<p>
    · Can be used to perform a function on a mediatype component after its
    display and edit_media_component methods are called
</p>
<ul>
    <li>
        Called from Media::as_content
    </li>
</ul>
<p>
    · arguments passed: $each_component (media player being displayed), $vce
</p>
<p>
    · no return
</p>
<h4>
    media_before_display
</h4>
<p>
    · Can be used to perform a function on a mediatype component before its
    display method is called
</p>
<ul>
    <li>
        Called from Media::as_content
    </li>
</ul>
<p>
    · arguments passed: $each_component (media player being displayed), $vce
</p>
<p>
    · no return
</p>
<h4>
    media_create_component
</h4>
<p>
    · Can be used to alter the input for a new media component before it’s
    created
</p>
<ul>
    <li>
        Called from Media::create and Mediaplupload:create
    </li>
    <li>
        arguments passed: $input used to create media component
    </li>
</ul>
<p>
    · return $input array
</p>
<h4>
    media_component_created
</h4>
<ul>
    <li>
        Called after a new media component is created
    </li>
    <li>
        Called from Media::create
    </li>
</ul>
<p>
    · arguments passed: $input used to create media component, $response array
</p>
<p>
    · return $response
</p>
<h4>
    media_file_uploader
</h4>
<ul>
    <li>
        Can be used to add content before the file upload button
    </li>
    <li>
        Called from Media::add_file_uploader
    </li>
    <li>
        arguments passed: $recipe_component, $vce
    </li>
    <li>
        return $content_media that is added to the page
    </li>
</ul>
<h4>
    media_update_component
</h4>
<ul>
    <li>
        Called from Media::update before update_component method is called
    </li>
    <li>
        arguments passed: $input used for update
    </li>
    <li>
        return $input
    </li>
</ul>
<h4>
    media_delete_component
</h4>
<ul>
    <li>
        Called from Media::delete before delete_component method is called
    </li>
    <li>
        arguments passed: $input used for delete
    </li>
    <li>
        return $input
    </li>
</ul>
<h4>
    page_add_recipe
</h4>
<p>
    · called when recipe is added to $page in get_components and
    get_sub_components
</p>
<ul>
    <li>
        Page::get_components
    </li>
</ul>
<p>
    · arguments passed: $page-&gt;recipe and recipe found in current component
</p>
<p>
    · return recipe, which is assigned to $page
</p>
<h4>
    page_build_content
</h4>
<p>
    · called for each component at the beginning of Build Content process
</p>
<p>
    · called in Page::build_content
</p>
<p>
    · arguments passed: $each_component from $components array, $linked
</p>
<p>
    · no return value
</p>
<h4>
    page_build_content_callback
</h4>
<p>
    · Called before recursive call to build_content for current component
</p>
<p>
    · Called in Page::build_content
</p>
<p>
    · Arguments passed: $sub_components from current component
</p>
<p>
    · returns $sub_components
</p>
<h4>
    page_construct_object
</h4>
<p>
    · called in Page::__construct after requested_component object is pulled
    from db
</p>
<p>
    · arguments passed: $requested_component, $vce
</p>
<p>
    · no return value
</p>
<h4>
    page_get_components
</h4>
<p>
    · Called in Page::get_components before recursive call back to
    get_components
</p>
<p>
    · arguments passed: $requested_component, $components, $page
</p>
<ul>
    <li>
        no return
    </li>
</ul>
<h4>
    page_get_sub_components
</h4>
<p>
    · Called in Page::get_sub_components before building full sub_components
    tree
</p>
<p>
    · arguments passed: $requested_components
</p>
<ul>
    <li>
        return $requested_components
    </li>
</ul>
<h4>
    page_requested_components
</h4>
<p>
    · Can be used to alter $requested_component at the beginning of
    get_components method
</p>
<p>
    · Called at start of Page::get_components, after call to db to get
    requested component object
</p>
<p>
    · arguments passed: $requested_component
</p>
<ul>
    <li>
        return $requested_component
    </li>
</ul>
<h4>
    page_requested_url
</h4>
<p>
    · Called in Page::__construct after $requested_url is cleaned up and
    sanitized
</p>
<ul>
    <li>
        arguments passed: $requested_url, $vce
    </li>
    <li>
        no return
    </li>
</ul>
<h4>
    recipe_attributes
</h4>
<p>
    · Adds fields on recipe page after Recipe Name
</p>
<p>
    · called in ManageRecipes::as_content
</p>
<p>
    · arguments passed: $vce-&gt;user
</p>
<p>
    · returns string of HTML content with additional attributes, to be added to
    Manage Recipe page
</p>
<h4>
    recipe_components_each
</h4>
<ul>
    <li>
        Components::recipe_components
    </li>
</ul>
<h4>
    requested_sub_components
</h4>
<p>
    · Called at start of Page::get_sub_components, after call to db to get
    array of sub components
</p>
<p>
    · arguments passed: $requested_components
</p>
<ul>
    <li>
        return $requested_components
    </li>
</ul>
<h4>
    site_hook_initiation
</h4>
<p>
    · The earliest hook that can be used
</p>
<p>
    · called in Site:__construct
</p>
<p>
    · arguments passed: $hooks array
</p>
<p>
    · no return value
</p>
<h4>
    site_javascript_dependencies
</h4>
<p>
    · can be used to alter the site-&gt;javascript_dependencies array
</p>
<p>
    · called in Site::__construct after javascript &amp; CSS files are added to
    site
</p>
<p>
    · arguments passed: $site, $site-&gt;javascript_dependencies
</p>
<p>
    · return javascript_dependencies array
</p>
<h4>
    site_mail_transport
</h4>
<p>
    · can be used to route mail message to a different transport method
</p>
<p>
    · if it exists, is called in VCE::mail instead of PHP mailer call
</p>
<p>
    · arguments passed: $vce, $attributes
</p>
<p>
    · return status of message call
</p>
<h4>
    site_media_link
</h4>
<p>
    · can be used to alter path to which media is uploaded
</p>
<ul>
    <li>
        called in Site::media_link after $media_link path is built
    </li>
</ul>
<p>
    · arguments passed: $fileinfo arrray, $this
</p>
<ul>
    <li>
        returns $media_link
    </li>
</ul>
<h4>
    site_object_construct
</h4>
<p>
    · Can be used to modify the site object
</p>
<p>
    · called in Site::__construct
</p>
<p>
    · arguments passed: $site object
</p>
<p>
    · no return value
</p>
<h4>
    user_attributes
</h4>
<p>
    · Used to add additional user attributes
</p>
<p>
    · called in: ManageUsers::as_content, UserRegistration::as_content,
    UserSettings::as_content
</p>
<p>
    · arguments passed: $user_info array
</p>
<p>
    · returns string of HTML content with additional user attributes, to be
    added to Manage Users page
    <br/>
    <br/>
</p>
<h2>
    <a name="_Toc517175197"></a>
    <a name="_Templates_1"></a>
    Templates
</h2>
<ul>
    <li>
        existing
    </li>
</ul>
<p>
    · creating a new one
</p>
<h3>
    <a name="_Toc517175198">JavaScript Dependencies</a>
</h3>
<p>
    · How to add a new .js file
</p>
<p>
    · Files used in system
</p>
<p>
    o jQuery
</p>
<p>
    o JSON
</p>
<p>
    o vce.js
</p>
<p>
    o other js files used in system (manage components…?)
</p>
<ul>
    <li>
        clickbars?
    </li>
</ul>
<h3>
    <a name="_Toc517175199">CSS dependencies</a>
</h3>
<p>
    · How to add a new .css file
</p>
<p>
    · Files used in system
</p>
<p>
    o jQuery
</p>
<h2>
    <a name="_Toc517175200">Cron Tasks</a>
</h2>
<p>
    Cron tasks allow you to schedule tasks for the system. These cron tasks are
    defined by methods within Components Classes that are called during page
    build. Cron tasks are useful when you need to sync with external systems,
    such as connecting to external service providers. They can also be used for
    general housekeeping – in Nestor they go through user comments looking for
    any blank entries and deleting them every day.
</p>
<h4>
    Data Structure
</h4>
<p>
    A cron task takes the form of a record in the site_meta table, and contains
    the following information:
</p>
<table border="1" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td width="198" valign="top">
                <p>
                    component
                </p>
            </td>
            <td width="738" valign="top">
                <p>
                    Name of the Component Class that contains the method to be
                    called
                </p>
            </td>
        </tr>
        <tr>
            <td width="198" valign="top">
                <p>
                    method
                </p>
            </td>
            <td width="738" valign="top">
                <p>
                    Name of the method to call. Since cron_tasks are called
                    before the components are instantiated, the method needs to
                    be static
                </p>
            </td>
        </tr>
        <tr>
            <td width="198" valign="top">
                <p>
                    properties
                </p>
            </td>
            <td width="738" valign="top">
                <p>
                    A list of key/value pairs to provide more information about
                    the task, for example the component_id
                </p>
            </td>
        </tr>
        <tr>
            <td width="198" valign="top">
                <p>
                    timestamp
                </p>
            </td>
            <td width="738" valign="top">
                <p>
                    A timestamp value to indicate when the task has expired
                </p>
            </td>
        </tr>
    </tbody>
</table>
<h4>
    Cron Task Management
</h4>
<p>
    During the page build process, the Site class loads all of the cron tasks
    from the site_meta table into a cron_tasks array, and then parses through
    the array to look for any expired timestamps. If a task has an expired
    timestamp, the Site class will call the method indicated by the cron task.
    If this method sends a response in the form of an array, the Site class
    updates the cron task with the new values. If the method does not send a
    response the Site class will delete this task from the system. See the
    <a
        href="https://uwnetid.sharepoint.com/sites/og_cultivate-learning-nestor/Shared%20Documents/Documentation/Site%20Class.docx?web=1"
    >
        Site Class API
    </a>
    for information about how to form a response to manage a cron task.
</p>
<p>
    Since the tasks are performed during the Page build process, the tasks are
    only fired when you have visitors to your site.
</p>
<h4>
    Throttling Cron Tasks
</h4>
<p>
    The CRON_TASK_LIMIT value in the system config file sets the amount of cron
    tasks that will be processed on page load. This allows you to balance the
    load on your system. The amount of cron tasks run on each page load
    defaults to 1 if CRON_TASK_LIMIT isn’t set.
</p>
<h3>
    <a name="_Toc517175201">Session Variables</a>
</h3>
<p>
    · add_attributes Session variables used by the system, especially for
    persistent values?
</p>
<p>
    <a name="_Building_a_Component"></a>
    <a name="_JavaScript_Dependencies"></a>
    <a name="_CSS_dependencies"></a>
    <a name="_Templates"></a>
    <a name="_Hooks"></a>
    <a name="_Cron_Tasks"></a>
</p>