<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Nestor Documentation</title>
  <link rel="stylesheet" href="css/style.css">
  <script type="text/javascript" src="js/scripts.js"></script>
</head>
<body onload="includeHTML()">
  <div id="menu" menu-html="menu.html">

  </div>

  <div class="main">
    <p>
      This Guide will walk through:
  </p>
  <ol>
      <li><a href="#properties"></a>Properties associated with components and how to assign values to them</a></li>
      <li><a href="#methods">Methods available to be overwritten, and how they interact with the core
          Nestor engine classes</a></li>
      <li>Static methods called from the parent Component class that are essential to system processes. <strong>We strongly advise you not to alter these static methods</strong>.</li>
      <li><a href="#core_functions">Core Functions</a> that you may want to add to your component
      that need to be routed properly through Nestor for them to work. These include functions such as
      <a href="#form_submission">form submission</a> and <a href="#file_upload">file upload</a>.
      </li>
      <li><a href="#form_submission">How to Build a Component with Minions</a></li>
      <li><a href="#form_submission">Troubleshooting tools</a> to help you trace issues in your code.</li>
  </ol>
  
     
  <p>
      5) 
  </p>


  <table border="1" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td width="935" valign="top">
                <h2>
                    <a name="core_functions">Core </a>
                    Functions
                </h2>
            </td>
        </tr>
    </tbody>
</table>
<p>
    In order for your Component to take full advantage of the security and flow
    continuity provided by the Nestor framework, certain functions need to be
    routed properly.
</p>
<table border="1" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td width="935" valign="top">
                 
                    <a name="form_submission">Form Submission</a>
                 
            </td>
        </tr>
    </tbody>
</table>
<p>
    Nestor has a specific procedure that must be followed to eliminate common
    form submission security vulnerabilities.
</p>
<p>
    If you’d like to collect and process user data with your component, there
    are a few pieces that need to be in place. Many of these are provided by
    the Nestor framework by default, but you will need to manage some of them
    in your code. Once you understand the form submission procedure, you will
    be able to take full advantage of it to interact with your end users.
</p>
 
    Form Submission Process
 
<p>
    1) Any form with the class "asynchronous-form" will invoke the submit
    function in vce.js, and the form will be submitted asynchronously
</p>
<p>
    2) The form is submitted to the path designated by $vce-&gt;input_path. By
    default this is [<span class="italic">my_site_url</span>]/input
</p>
<p>
    3) Form input is routed to input/input.php, which decrypts the dossier and
    sanitizes and re-keys all dossier and form field values into an input array
</p>
<p>
    4) Input Class checks if there is a form_input method in specified class,
    if not it calls form_input in Component class
</p>
<p>
    5) Form_input routes the input array to the designated procedure – which is
    the class/method in the dossier
</p>
<p>
    6) Procedure processes the data
</p>
<p>
    7) Control passed back to originating javascript call, which displays any
    messages echoed by PHP methods
</p>
 
    Form Fields
 
<p>
    Your component needs to create the HTML content for the form fields, which
    must include values for the following.
</p>
<p>
    1) A hidden input that contains an encrypted dossier. A dossier is
    basically an array of values that designate the component type, the
    procedure that is called in the component when the form is submitted, the
    component_id and the “created_at” value. Other values can be added based on
    your component’s needs. The encrypted dossier is generated by calling
    $vce-&gt;page-&gt;generate_dossier($dossier).
</p>
<p>
    Depending on what point in the page build process you are calling this
    method, the component may already have dossiers available for create,
    update and delete. If these suit your needs you can use them without having
    to generate a new dossier. But sometimes it’s just safer to go ahead and
    create the dossier before you use it.
</p>
<p>
    2) A hidden input that contains the site input path, designated by
    $vce-&gt;input_path
</p>
<p>
    3) Your form fields from which you’ll collect user data
</p>
 <h3>
    Example – Generating a Dossier and Creating Form Fields
</h4>
<p>
    The Blog-o-rama example has a create_contact_form method that shows how to
    generate a dossier and populate form fields with hidden values.
</p>
<table border="1" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td width="935" valign="top">

                    public function create_contact_form($each_component, $vce)
                    {


                    $dossier = array(


                    'type' =&gt; 'Blogorama',


                    'procedure' =&gt; 'update_contact',


                    'component_id' =&gt; $each_component-&gt;component_id,


                    'created_at' =&gt; $each_component-&gt;created_at


                    );


                    // generate dossier


                    $each_component-&gt;dossier_for_contact =


                    $vce-&gt;generate_dossier($dossier);


                    $contact_form = &lt;&lt;&lt;EOF


                    &lt;div id="text-block-container add-container"&gt;


                    &lt;div class="clickbar-container"&gt;


                    &lt;div class="clickbar-content"&gt;


                    &lt;form id="create_media" class="asynchronous-form"
                    method="post" action="$vce-&gt;input_path"
                    autocomplete="off"&gt;


                    &lt;input type="hidden" name="dossier"
                    value="$each_component-&gt;dossier_for_contact"&gt;


                    &lt;input type="hidden" name="title" value="Contact
                    Info"&gt;


                    &lt;label&gt; &lt;input type="text"
                    name="contact_email"&gt; &lt;div class="label-text"&gt;
                    &lt;div class="label-message"&gt;Email&lt;/div&gt; &lt;div
                    class="label-error"&gt;Enter an email&lt;/div&gt;
                    &lt;/div&gt; &lt;/label&gt;


                    &lt;input type="hidden" name="sequence"
                    value="$each_component-&gt;sequence"&gt;


                    &lt;input type="submit" value="Sign Up"&gt;


                    &lt;/form&gt;


                    &lt;/div&gt;


                    &lt;div class="clickbar-title
                    clickbar-closed"&gt;&lt;span&gt;Contact
                    Form&lt;/span&gt;&lt;/div&gt;


                    &lt;/div&gt;


                    &lt;/div&gt;


                    EOF;


                    return $contact_form;


                    }

            </td>
        </tr>
    </tbody>
</table>
<p>
    The create_contact_form method is called from as_content in the Blogorama
    class to allow the form content to be written to the rendered page.
</p>
<table border="1" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td width="935" valign="top">

                    public function as_content($each_component, $vce) {


                    //$my_content = $this-&gt;component_info();


                    $display_content = "Blog-o-rama says hello!";


                    $display_content .=
                    $this-&gt;create_contact_form($each_component,


                    $vce);


                    $vce-&gt;content-&gt;add('main', $display_content);


                    }

            </td>
        </tr>
    </tbody>
</table>
 
    Processing Data from your Component
 
<p>
    The simplest way to receive data is to use the inherent update function in
    the Component class. In this case you’d use a procedure value of ‘update’
    in the dossier. By default, the ‘update’ procedure will update any existing
    metadata, or add metadata with keys that do not currently exist in the
    components_meta table for the designated component.
</p>
<p>
    If you want to perform anything more complex, you’ll need to write a method
    that matches the name of the procedure you used in your dossier. This
    method can process your data using many of the Nestor features, such as
    creating/updating datalists, updating component metadata, or simply
    changing the display.
</p>
<p>
    In the Blogorama example, the update_contact method is the designated
    procedure in the dossier. In this case the method calls to the
    $vce-&gt;dump method which simply echos the contents of the array to the
    page.
</p>
<p>
    The echo command returns a message to the originating js call, which will
    be displayed on your page once the server is finished processing data.
</p>
<table border="1" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td width="935" valign="top">

                    public function update_contact($input) {


                    global $vce;


                    $vce-&gt;dump($input);


                    echo json_encode(array('response' =&gt; 'success',


                    'procedure' =&gt; 'create','action' =&gt; 'reload',


                    'message' =&gt; 'This is only a test'));


                    return;


                    }

            </td>
        </tr>
    </tbody>
</table>
 
    Ways to Subvert the Form Submission Process
 
<p>
    1) Overwrite the form_input method from the parent Component class. Be
    careful if you do this, and make sure to keep the important elements that
    allow your input to be processed
</p>
<p>
    2) Write a custom method to process your data, and make sure it’s the
    designated procedure in your dossier
</p>
<p>
    3) Customize your form fields that you add to a page. You can have multiple
    forms with multiple dossiers
</p>
<p>
    4) Overwrite the input path and create your own component to route the
    data.
</p>

<p><a href="#methods">Back to Top</a>

<table border="1" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td width="935" valign="top">
                 
                    <a name="file_upload">File Upload</a>
                 
            </td>
        </tr>
    </tbody>
</table>
<p>
    There are some components which allow a user to upload a file. This can be
    useful in many scenarios. There are two methods involved in building and
    adding the file upload element to a page:
</p>
<p>
    1) File_upload returns true or false. The file upload element will only be
    added if this method returns true. Use this method to test conditions to
    determine if the element should be added to the page.
</p>
<p>
    2) Add_file_uploader will create the HTML content to add a file upload
    element to the page, and returns this content.
</p>
<p>
    The Blogorama Class has a working example using the file_upload and
    add_file_uploader methods to add a file upload element to the page.
</p>

<p><a href="#methods">Back to Top</a>

<table border="1" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td width="935" valign="top">
                <h2>
                    <a name="troubleshooting_tools">Troubleshooting Tools</a>
                </h2>
            </td>
        </tr>
    </tbody>
</table>
<p>
    The complexity of Nestor allows the system a great deal of flexibility,
    however it can lead to some difficult troubleshooting scenarios. There are
    some useful functions that will help you trace and debug your code.
</p>
<table border="1" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td width="935" valign="top">
                 
                    Dump
                 
            </td>
        </tr>
    </tbody>
</table>
<p>
    The dump method located in $vce allows you to display the contents of a
    value to the screen. Note that this doesn’t always work, depending on what
    point during the page build process you call the function.
</p>
<table border="1" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td width="935" valign="top">

                    dump($var, $color = 'ffc')

            </td>
        </tr>
    </tbody>
</table>
 <h3>
    Parameters
</h4>
<table border="1" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td width="198" valign="top">

                    $var

            </td>
            <td width="162" valign="top">

                    Mixed

            </td>
            <td width="576" valign="top">

                    If given a
                    <a
                        href="http://php.net/manual/en/language.types.string.php"
                    >
                        string
                    </a>
                    ,
                    <a
                        href="http://php.net/manual/en/language.types.integer.php"
                    >
                        integer
                    </a>
                    or
                    <a href="http://php.net/manual/en/language.types.float.php">
                        float
                    </a>
                    , the value itself will be printed. If given an
                    <a href="http://php.net/manual/en/language.types.array.php">
                        array
                    </a>
                    , values will be presented in a format that shows keys and
                    elements.

            </td>
        </tr>
        <tr>
            <td width="198" valign="top">

                    $color

            </td>
            <td width="162" valign="top">

                    String

            </td>
            <td width="576" valign="top">

                    Hex value for the color of the background shown behind the
                    value printed

            </td>
        </tr>
    </tbody>
</table>
 <h3>
    Return
</h4>
<table border="1" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td width="198" valign="top">
            </td>
            <td width="738" valign="top">

                    No values returned

            </td>
        </tr>
    </tbody>
</table>
 <h3>
</h4>
 <h3>
    Example<strong></strong>
</h4>
<table border="1" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td width="935" valign="top">

                    $vce-&gt;dump($each_component);

            </td>
        </tr>
    </tbody>
</table>

<p><a href="#methods">Back to Top</a>

<table border="1" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td width="935" valign="top">
                 
                    Log
                 
            </td>
        </tr>
    </tbody>
</table>
<p>
    If you aren’t seeing results using the dump function, or the logic you are
    testing is in a complex chain of function calls, using the $vce log
    function can be very useful. Anything you send to $vce-&gt;log will be
    added to the log.txt file found in the root folder of your Nestor
    installation. You can designate a different file, just know that the path
    will be built from your root folder.
</p>
<table border="1" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td width="935" valign="top">

                    log($var, $file = "log.txt")

            </td>
        </tr>
    </tbody>
</table>
 <h3>
    Parameters
</h4>
<table border="1" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td width="198" valign="top">

                    $var

            </td>
            <td width="162" valign="top">

                    Mixed

            </td>
            <td width="576" valign="top">

                    Can be any type except a
                    <a
                        href="http://php.net/manual/en/language.types.resource.php"
                    >
                        resource
                    </a>

            </td>
        </tr>
        <tr>
            <td width="198" valign="top">

                    $file

            </td>
            <td width="162" valign="top">

                    String (Optional)

            </td>
            <td width="576" valign="top">

                    Name of the file to which information will be written.
                    Defaults to log.txt.

            </td>
        </tr>
    </tbody>
</table>
 <h3>
    Return
</h4>
<table border="1" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td width="198" valign="top">
            </td>
            <td width="738" valign="top">

                    No values returned

            </td>
        </tr>
    </tbody>
</table>
 <h3>
</h4>
 <h3>
    Example<strong></strong>
</h4>
<table border="1" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td width="935" valign="top">

                    //send components array details to the log file


                    $var = $vce-&gt;page-&gt;components;


                    $vce-&gt;log($var);

            </td>
        </tr>
    </tbody>
</table>

<p><a href="#methods">Back to Top</a>

<table border="1" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td width="935" valign="top">
                 
                    Displaying Errors from Asynchronous Calls
                 
            </td>
        </tr>
    </tbody>
</table>
<p>
    Many of the features of Nestor rely on asynchronous calls to the server.
    Errors on the server can be easily masked this way. Use the echo command to
    send messages back to the originating javascript call, which will display
    these messages.
</p>
 <h3>
    Example
</h4>
<p>
    The create method of Component returns a success message if component was
    created, and an error message if not. A return value of ‘success’ will
    cause the page to reload, a return value of ‘error’ will display an error
    message on the page.
</p>
<table border="1" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td width="935" valign="top">

                    if ($component_id) {


                    global $site;


                    $site-&gt;add_attributes('message',self::component_info()


                    ['name'] . ' Created');


                    echo json_encode(array('response' =&gt; 'success',


                    'procedure' =&gt; 'create','action' =&gt; 'reload',


                    'message' =&gt; 'Created','component_id' =&gt;
                    $component_id));


                    return;


                    } else {


                    echo json_encode(array('response' =&gt; 'error',


                    'procedure' =&gt; 'update','message' =&gt; "Error"));


                    return;


                    }

            </td>
        </tr>
    </tbody>
</table>
<table border="1" cellspacing="0" cellpadding="0"  id="add_a_hook">
    <tbody>
        <tr>
            <td width="935" valign="top">
                 
                    Adding a Hook
                 
            </td>
        </tr>
    </tbody>
</table>
<p>
    Hooks are a powerful tool that allow your component to 'hook into' the
    Nestor engine at various stages of the page build process, as well as any
    place in the code where a hook has been inserted. A hook is configured
    within a component class and designates a class and method to call when the
    hook is invoked within the system. In the Nestor system, a class/method
    pairing is known as a procedure.
</p>
<p>
    Read the Hooks Section for detailed information about what hooks are
    available in the Nestor system and how they can influence the function of
    the core engine classes.
</p>
 
    Hook configuration
 
<p>
    During the page build process, the procedure/hook associations are loaded
    into a hooks array that’s added to the global $site object. The Hooks
    Definition and Load Process flow chart shows the end-to-end process of
    defining a hook and loading into the system for use.
</p>
<p>
    To assign a procedure to a hook, overwrite the preload_component method in
    your component.
</p>
 <h3>
    Hook configuration example<strong></strong>
</h4>
<table border="1" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td width="935" valign="top">

                    public function preload_component() {


                    $content_hook = array (


                    'page_requested_url' =&gt; 'Input::page_requested_url'


                    );


                    return $content_hook;


                    }

            </td>
        </tr>
    </tbody>
</table>
<table border="1" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td width="935" valign="top">
                 
                    Build a Component with Minions
                 
            </td>
        </tr>
    </tbody>
</table>
<p>
    There are some cases where you may want to create a component that will
    have a number of sub-components, referred to as Minions, that it can
    interact with in a standardized manner. The Media/MediaType Components are
    an example of this relationship.
</p>
<p>
    You can add a Media component to a recipe, and then in the recipe you can
    designate which of its Minions will be available for end users to add to
    their page. Minion components must be installed and activated before they
    will appear as an option in the Media component configuration in a Recipe.
    In the figure below, you can see the Image, Text, and PDF Minions appear in
    the Media component configuration.
</p>
<p>
    <img
        border="0"
        width="803"
        height="510"
        src="file:///C:/Users/cdoring/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg"
    />
</p>
<p>
    <span class="italic">Media component in a recipe with Minion selection</span>
</p>
<p>
    <img
        border="0"
        width="936"
        height="277"
        src="file:///C:/Users/cdoring/AppData/Local/Temp/msohtmlclip1/01/clip_image003.png"
    />
</p>
<p>
    <span class="italic">
        Media content choices for the end user, all Minion types represented
    </span>
</p>
 
    Master/Minion Class Structure
 
<p>
    The master class (Media) extends Component class, while the Minion
    component classes extend a Minion parent class that you will need to
    create. In the case of the Media parent component, it’s Minions all extend
    Class MediaType. Each of these classes must contain methods to perform
    certain operations to make sure the Minions are properly associated with
    their Master component.
</p>
 
    Master Component Class
 
<p>
    The Master Class needs to perform the following operations to find and
    connect to its Minions.
</p>
<p>
    1) Create a hook in the preload_component method
</p>
<p>
    2) Use the hook to call a method that loads in the Minion Parent class (ie
    MediaType)
</p>
<p>
    3) In the as_content method, load in the list of minions. This list takes
the form of an array that’s a property of $site, labeled enabled_[    <span class="italic">Minion parent class name</span>]s. ( ie enabled_mediatypes)
</p>
<p>
    a. The enabled_[<span class="italic">Minion parent class name</span>]s array is created and
    populated by the Manage Components page each time the Master component is
    added or updated. It’s populated with all of its active Minions. It will be
    given the name enabled_[<span class="italic">Minion parent class name</span>]s by default.
</p>
<p>
    b. Cycle through the Minion array and load each of their class files
</p>
<p>
    4) Call a class, ie edit_media_component, to generate dossiers and to call
    the edit function of each Minion
</p>
<p>
    5) In the add_component function, add code to make sure each minion shows
    up as a checkbox
</p>
<p>
    6) Create a subfolder under the master folder for the Minion parent class
    files
</p>
 
    Minion Classes
 
<p>
    1) Create a separate folder in the [my_nestor]-content\components folder to
    host each minion, create a class file for each Minion in its respective
    folder
</p>
<p>
    2) The parent Minion class should have a generic methods for display that
    each Minion will overwrite
</p>
<p>
    3) The parent Minion class needs a method to add each Minion, using
    dossiers created by the master class
</p>
<p>
    4) The Minion classes will need to flesh out the display method to generate
    content for themselves
</p>

  </div><!--end main div-->

 
</body>
</html>
